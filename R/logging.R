#' Manage the current logging context.
#' 
#' Evaluate an expression within the context of specified logging outputs
#'
#' This function sets up one or more destinations for logging
#' messages, optionally each at its own threshold for detail level. It
#' then evaluates the given expression, and directs each logging
#' messages sent within the expression to every destination whose
#' threshold is higher than the message's detail level.
#' 
#' Each output destination has to be a file name, a connection object,
#' or a pair of "(destination, threshold_level)". If no output
#' destination is given, logging will use \code{stderr()} at the
#' "INFO" threshold.
#'
#' System messages generated by \code{stop}, \code{warning}, and
#' \code{message} are also caught and recorded in the active
#' destinations, thus easing adoption of existing code. Normally, only
#' \code{stop} will be let through for standard R error processing;
#' optionally, if \code{catch_system_messages} is \code{FALSE}, logr
#' will do the same for \code{warning}s and \code{message}s.
#'
#' @note If \code{expr} sets up its own calling handlers for system
#' messages, such as by using \code{supressWarnings}, those messages
#' will not be received by \code{with_logging} because of the
#' mechanics of R's condition handling system.
#'
#' @param expr expression to be evaluated
#' @param ... output destinations, see details below
#' @param threshold the default level used as the threshold for logging
#' outputs
#' @param catch_system_messages whether `warning` and `message` should
#' be let through for further processing by upstream active handlers
#'
#' @examples
#' with_logging({
#'   debug_log('entering the logged expression')
#'   info_log('hello there')
#'   warn_log('something is amiss')
#'   debug_log('exiting the logged expression')
#' })
#'
#' ## output to a file at detailed level and console at INFO
#' with_logging({
#'   debug_log('entering the logged expression')
#'   info_log('hello there')
#'   warn_log('something is amiss')
#'   debug_log('exiting the logged expression')
#' }, list(tempfile(), 'TRACE'), stderr())
#' 
#' @export
with_logging <- function(expr, ..., threshold = 'INFO', catch_system_messages = TRUE) {
    destinations <- list(...)
    if (length(destinations) == 0) {
        destinations <- list(stderr())
    }
    log_outputs <- make_log_output(threshold, destinations)
    on.exit(lapply(log_outputs, close.LogOutput))

    with_logging_call <- sys.call()
    
    withRestarts(
        withCallingHandlers(expr,
                            LoggingMessage = make_logging_handler(log_outputs),
                            condition = make_system_logging_handler(log_outputs, catch_system_messages)),
        resignal_with_call = function(cond) {
            cond$call <- with_logging_call
            if (inherits(cond, 'error')) {
                stop(cond)
            } else if (inherits(cond, 'warning')) {
                warning(cond)
            } else if (inherits(cond, 'message')) {
                message(cond)
            }
        })
}


#' @describeIn with_logging Evaluate an expression in a context that turns off all logging
#' @export
suppress_logging <- function(expr) {
    withCallingHandlers(expr,
                        LoggingMessage = function(cond) invokeRestart('muffle_logging'))
}


make_log_output <- function(default_threshold, destinations) {
    Reduce(function(outputs, d) {
        dd <- if (length(d) == 1) {
            LogOutput(d, default_threshold)
        } else if (length(d) == 2) {
            d <- as.list(d)
            LogOutput(d[[1]], d[[2]])
        } else stop('Each output destination has to be a file name, connection, or a pair of (destination, detail_threshold)')
        
        if (is.null(dd$threshold)) {
            close.LogOutput(dd)
            outputs
        } else {
            c(outputs, list(dd))
        }
    }, destinations, init = list())
}
