#' Manage the current logging context.
#' 
#' Evaluate an expression within the context of specified logging outputs
#'
#' This function sets up one or more destinations for logging
#' messages, optionally each at its own threshold for detail level. It
#' then evaluates the given expression, and directs each logging
#' messages sent within the expression to every destination whose
#' threshold is higher than the message's detail level.
#'
#' System messages generated by \code{stop}, \code{warning}, and
#' \code{message} are also recorded in the active destinations, but
#' then let through for further processing by any other calling
#' handlers active further up in the call chain. Conversely, if
#' \code{expr} setups its own calling handlers for those messages, for
#' instance \code{supressWarnings}, those messages will not be
#' received by \code{with_logging} because of the mechanics of R's
#' condition handling system.
#' 
#' Each output destination has to be a file name, a connection object,
#' or a pair of "(destination, detail_level)". If no output
#' destination is given, logging will use \code{stderr()} at the
#' "INFO" threshold.
#'
#' @param expr expression to be evaluated
#' @param ... output destinations, see details below
#' @param level the default level used as the threshold for logging
#' outputs
#'
#' @examples
#' with_logging({
#'   debug_log('entering the logged expression')
#'   info_log('hello there')
#'   warn_log('something is amiss')
#'   debug_log('exiting the logged expression')
#' })
#'
#' ## output to a file at detailed level and console at INFO
#' with_logging({
#'   debug_log('entering the logged expression')
#'   info_log('hello there')
#'   warn_log('something is amiss')
#'   debug_log('exiting the logged expression')
#' }, list(tempfile(), 'TRACE'), stderr())
#' 
#' @export
with_logging <- function(expr, ..., level = NA) {
    log_outputs <- make_log_output(level, ...)
    on.exit(lapply(log_outputs, close.LogOutput))

    with_logging_call <- sys.call()
    
    withRestarts(
        withCallingHandlers(expr,
                            LoggingMessage = make_logging_handler(log_outputs),
                            condition = make_system_logging_handler(log_outputs)),
        resignal_with_call = function(cond) {
            cond$call <- with_logging_call
            if (inherits(cond, 'error')) {
                stop(cond)
            } else if (inherits(cond, 'warning')) {
                warning(cond)
            } else if (inherits(cond, 'message')) {
                message(cond)
            }
        })
}


#' @describeIn with_logging Evaluate an expression in a context that turns off all logging
#' @export
suppress_logging <- function(expr) {
    withCallingHandlers(expr,
                        LoggingMessage = function(cond) invokeRestart('muffle_logging'))
}


make_log_output <- function(default_level, ...) {
    destinations <- list(...)
    if (length(destinations) == 0) {
        destinations <- list(stderr())
    }
    Reduce(function(outputs, d) {
        dd <- if (length(d) == 1) {
            if (!is.null(default_level) && is.na(default_level)) {
                LogOutput(d)
            } else {
                LogOutput(d, default_level)
            }
        } else if (length(d) == 2) {
            d <- as.list(d)
            LogOutput(d[[1]], d[[2]])
        } else stop('Each output destination has to be a file name, connection, or a pair of (destination, detail_level)')
        
        if (is.null(dd$level)) {
            close.LogOutput(dd)
            outputs
        } else {
            c(outputs, list(dd))
        }
    }, destinations, init = list())
}
