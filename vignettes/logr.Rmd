---
title: "Introduction to Logging with _'logr'_"
output:
  rmarkdown::html_vignette:
    mathjax: null
vignette: >
  %\VignetteIndexEntry{Introduction to logging with _logr_}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

The _logr_ package implements a logging framework that uses R's
existing messaging functionality, and builds upon it an API that is
simple to use. Because it shares the same underpinnings, _logr_ can
capture messages and warnings generated by `warning` and `message`,
making it easy to adopt even in a mature codebase.


Why a logging framework?
------------------------

For any non-trivial piece of code, there are times when it is
desirable to display information about its progress. The catch,
however, is that different audiences may require a different amount of
information at different times.

With base R, this is typically handled with a `verbose` argument to a
function, sometimes in conjunction with using `warning` vs `message`
to distinguish different types or importance of information. This
method has a number of drawbacks, such as that verbosity applies to
the directly called function only, or that all messages always go to
the screen (unless `sink` redirects them to a file, in which case
_nothing_ appears on the screen).

_logr_ addresses both of these, and more, issues:

- there are multiple predefined levels of message detail
- messages can be sent to more than one destination -- for instance,
  a file and the console -- and each destination can have a different
  threshold for the detail level of messages that it will output
- the logging threshold can be set for an entire block of running
  code, rather than just per-function, as with base R
- as an added bonus to the readability of your code, the interaction
  of message detail levels and destination thresholds means that you don't
  need to wrap every logging statement in an `if (verbose) ...`-type
  check: just send the messages, and let _logr_ decide what to
  display/record based on your current configuration.


Use
---

To start using this package, simply call one of the family of `*_log`
functions to output logging messages at the desired level of
importance. The functions are helpfully named after their detail
level, for instance `info_log` for level "INFO" (see the "Message
levels" section below for the full description of detail levels).

```r
info_log('Hello there')

if (sample(6, 1) == 1)
    warn_log('Not your lucky day')
trace_log(paste('x:', x))
```

With no further configuration, these logging messages will be received
by the default logging handler, which has only one destination,
`stderr()`, with the "INFO" threshold. What this means is that
out-of-the-box, the logging functions work similarly to related
functions in _base_: `info_log` will act exactly like `message` (it
can even be turned off with `suppressMessages`), `warn_log` as
`warning` and `error_log` as `stop`. Messages with detail level higher
than INFO (i.e., DEBUG and TRACE) will not be printed.

### Defining logging handlers
To exert finer control, define your own logging handler. This is done
by wrapping the code where you want to enable logging inside a call to
`with_logging`. This function has only one required argument, the
expression that is run with this logging handler in place. Optional
arguments allow you to specify logging destinations and thresholds.
Say, for instance, that we want to output at most informational
messages to the console while recording fine-level messages in a log
file:

```r
with_logging({
    info_log('Hello there')
    
    if (x <- sample(6, 1) == 1)
        warn_log('Not your lucky day')
    trace_log(paste('x:', x))
}, list('/var/tmp/myapp.log', 'DEBUG'), stderr())
```

The destination arguments are `list('/var/tmp/myapp.log', 'DEBUG')`
and `stderr()`. The first is a two-element list of the file name as
a string and an explicit level threshold. The second is just the
connection instance, which means that it will inherit the logger's
default threshold. The default threshold is itself specifiable with
the `level` argument, whose default value is "INFO". So we could have
equivalently have written this piece of code as:


```r
with_logging({
    info_log('Hello there')
    
    if (x <- sample(6, 1) == 1)
        warn_log('Not your lucky day')
    trace_log(paste('x:', x))
}, '/var/tmp/myapp.log', list(stderr(), 'INFO'), level = 'DEBUG')
```

### Message levels
_logr_ provides the following levels for message detail, from most to
least important:

- ERROR: serious, un-recoverable errors that prevent the code from
  continuing with further execution
- WARN: reporting "suspicious" events, for instance, unexpected NAs,
  or that some automatic corrective action has failed (e.g., maximum
  number of retries reached)
- INFO: informing on major steps that software is performing, without
  drowning in too much detail
- DEBUG: detailed steps taken by operations
- TRACE: use for very detailed debugging, like printing local variable
  values

These levels are similar to those used in
[_log4j_](http://logging.apache.org/log4j/) and other logging
frameworks, and have been proven to be sufficient for most uses.


Internals
---------

Existing messaging functionality in R -- that is, `stop`, `warning`,
and `message` -- uses R's condition system to emit messages (that is,
signal conditions). (See [source][stop.R].) These messages are
received by condition handlers, which invoke "restarts" with
well-known default behaviours. Special cases, such as
`suppressWarnings` ([source][suppressWarnings]), are just condition
handlers that invoke non-default restarts, in the case of
`suppressWarnings` the restart that does nothing.

It will then come as no surprise to you that _logr_ uses the same
mechanism: message statements signal conditions of custom class
`LogMessage`; logging handlers are R's condition handlers run inside
`withConditionHandlers` and listening to messages of this class, as
well as classes used by `stop`, `warning`, and `message`.

For the most part, this will "just work" and you don't have to worry
about it. But keep the mechanism in mind if you have your own
condition handling in place. If you have a custom condition handler
(including with `try` and `tryCatch`) somewhere in the code that's run
`with_logging`, and this handler indiscriminately catches all
conditions and intercepts those with class `LogMessage`, you will
break _logr_'s communication mechanism and nothing will be logged!


Why be different from Log4j?
----------------------------

Most logging packages today seem to copy Java log4j API. It's
important to remember that Log4j originated as the logging code for
the Apache web server. As such, it was designed for use in large,
long-running, and complex applications that contain many subsystems
and potentially produce many output events every second.

_Logr_ instead targets a lighter-weight usage scenario -- arguably
more likely in an R codebase -- of a relatively short, often
interactive script or command-line utility. To this purpose, _logr_
provides a minimal API with sensible defaults that requires little
effort to use in code, while still allowing multiple logging
destinations, each with its own level of detail.

Furthermore, I believe that messages, warnings, and errors produced by
the dependent code -- whether from core R packages, CRAN, or elsewhere
-- can be relevant and so need to be loggable. This is why _logr_
builds on R's existing messaging functionality that uses conditions,
handlers, and restarts.

The result, I hope, is a logging framework that is simple,
unobtrusive, and pleasant to use. Enjoy!

[stop.R]: https://svn.r-project.org/R/trunk/src/library/base/R/stop.R

[suppressWarnings]: https://svn.r-project.org/R/trunk/src/library/base/R/conditions.R
