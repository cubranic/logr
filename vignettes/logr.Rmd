---
title: "Introduction to Logging with _'logr'_"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to logging with _logr_}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

The _logr_ package implements a logging framework that uses R's
existing messaging functionality, and builds upon it an API that is
simple to use. Because it shares the same underpinnings, _logr_ can
capture messages and warnings generated by `warning` and `message`,
making it easy to adopt even in a mature codebase.


Concepts
--------

At its base, logging is simply the recording of messages about the
progress of a running program on some sort of output device(s). We can
get a lot fancier in terms of configurability, flexibility, and other
features, but the underlying concepts remain the same:

- Logging message: emitted by logging statements in your code,
  resulting in an entry in the log.
  
- Detail level: a value attached to the logging message that specifies
  how important it is, for instance, whether it is a warning or merely
  informational.
  
- Destination: a file, console, or any other writeable connection that
  contains the log. Each destination has an attached threshold,
  denoting the maximum message detail level that it will allow through
  -- the lower the threshold, the less detail will be recorded.
  
- Handler: a listener to logging messages whose responsibility is to
  route the messages to a set of destinations. The default handler has
  only one destination, `stderr()`, with the "INFO" threshold, so that
  it behaves similarly to using `stop`, `warning`, and `message`.
  (Read on, though, it's worth switching to _logr_!)


### Message levels

The value of having a detail level and corresponding thresholds in
messages and destinations is that you can liberally write logging
statements in your code, tagged with the appropriate detail level, but
not overwhelm the output in a destination by keeping its detail
threshold sufficiently low. When it's needed, you can get different
amounts of output without changing anything in your code -- just raise
the threshold of active destinations when you need to -- for example,
while debugging. Finally, as an added bonus to the readability of your
code, the interaction of levels and thresholds means that you don't
need to wrap every logging statement in an `if (verbose) ...`-type
check: just emit the messages, and let the handler and its
destinations decide what to display/record.

_logr_ provides the following levels for message detail, from most to
least important:

- ERROR: serious, un-recoverable errors that prevent the code from
  continuing with further execution
- WARN: reporting "suspicious" events, for instance, unexpected NAs,
  or that some automatic corrective action has failed (e.g., maximum
  number of retries reached)
- INFO: informing on major steps that software is performing, without
  drowning in too much detail
- DEBUG: detailed steps taken by operations
- TRACE: use for very detailed debugging, like printing local variable
  values

These levels are similar to those used in
[_log4j_](http://logging.apache.org/log4j/) and other logging
frameworks, and have been proven to be sufficient for most uses.


Use
---

To start using this package, simply call one of the family of `*_log`
functions to output logging messages at the desired level of
importance. The functions are helpfully named after their detail
level, for instance `info_log` for level "INFO".

```r
info_log('Hello there')

if (sample(6, 1) == 1)
    warn_log('Not your lucky day')
trace_log(paste('x:', x))
```

As mentioned above, with no other configuration this will use the
default logging handler, which has only one destination, `stderr()`,
with the "INFO" threshold. What this means is that out-of-the-box, the
logging functions work similarly to related functions in _base_:
`info_log` will act exactly like `message` (it can even be turned off
with `suppressMessages`), `warn_log` as `warning` and `error_log` as
`stop`. Messages with detail level higher than INFO (i.e., DEBUG and
TRACE) will not be printed.

To exert finer control, define your own logging handler. This is done
by wrapping the code where you want to enable logging inside a call to
`with_logging`. This function has only one required argument, the
expression that is run with this logging handler in place. Optional
arguments allow you to specify logging destinations and thresholds.
Say, for instance, that we want to output at most informational
messages to the console while recording fine-level messages in a log
file:

```r
with_logging({
    info_log('Hello there')
    
    if (x <- sample(6, 1) == 1)
        warn_log('Not your lucky day')
    trace_log(paste('x:', x))
}, list('/var/tmp/myapp.log', 'DEBUG'), stderr())
```

The destination arguments are `list('/var/tmp/myapp.log', 'DEBUG')`
and `stderr()`. The first is a two-element list of the file name as
a string and an explicit level threshold. The second is just the
connection instance, which means that it will inherit the logger's
default threshold. The default threshold is itself specifiable with
the `level` argument, whose default value is "INFO". So we could have
equivalently have written this piece of code as:


```r
with_logging({
    info_log('Hello there')
    
    if (x <- sample(6, 1) == 1)
        warn_log('Not your lucky day')
    trace_log(paste('x:', x))
}, '/var/tmp/myapp.log', list(stderr(), 'INFO'), level = 'DEBUG')
```

Internals
---------

Existing messaging functionality in R -- that is, `stop`, `warning`,
and `message` -- uses R's condition system to emit messages (that is,
signal conditions). (See [source][stop.R].) These messages are
received by condition handlers, which invoke "restarts" with
well-known default behaviours. Special cases, such as
`suppressWarnings` ([source][suppressWarnings]), are just condition
handlers that invoke non-default restarts, in the case of
`suppressWarnings` the restart that does nothing.

It will then come as no surprise to you that _logr_ uses the same
mechanism: message statements signal conditions of custom class
`LogMessage`; logging handlers are R's condition handlers run inside
`withConditionHandlers` and listening to messages of this class, as
well as classes used by `stop`, `warning`, and `message`.

For the most part, this will "just work" and you don't have to worry
about it. But keep the mechanism in mind if you have your own
condition handling in place. If you have a custom condition handler
(including with `try` and `tryCatch`) somewhere in the code that's run
`with_logging`, and this handler indiscriminately catches all
conditions and intercepts those with class `LogMessage`, you will
break _logr_'s communication mechanism and nothing will be logged!


Why be different from Log4j?
----------------------------

Most logging packages today seem to copy Java log4j API. It's
important to know that Log4j originated as the logging code for the
Apache web server. As such, it was designed for use in large,
long-running, and complex applications that contain many subsystems
and potentially produce many output events every second.

I believe most R code is not at all like that and therefore for such
code log4j-style logging API is needlessly complex and arcane. This is
why _logr_ provides an API that's as simple as possible for most
typical uses while still allowing multiple logging destinations, each
with its own level of detail.

Furthermore, I think that messages, warnings, and errors produced by
the dependent code -- whether from core R packages, CRAN, or elsewhere
-- can be relevant and so need to be loggable. This is why _logr_
builds on R's existing messaging functionality that uses conditions,
handlers, and restarts.

The result, I hope, is a logging framework that is simple,
unobtrusive, and pleasant to use. Enjoy!

[stop.R]: https://svn.r-project.org/R/trunk/src/library/base/R/stop.R

[suppressWarnings]: https://svn.r-project.org/R/trunk/src/library/base/R/conditions.R
